
# 二叉树

---

## 二叉树遍历

### 144、二叉树的前序遍历[Medium]

* 前序遍历：根结点 ---> 左子树 ---> 右子树

* 用一个栈记录节点
* 当前的root结果记录到输出,**right和left**先后压入栈中(left整个左支路先压完的)
* 一直循环到栈为空

### 94、二叉树的中序遍历[Medium]

* 中序遍历：左子树 ---> 根结点 ---> 右子树

* 一直往左,并压入栈
* 看栈尾节点的值弹出并添加进结果(此时这个节点左边和当前节点都已经压入结果中),节点往右

### 145、二叉树的后序遍历[Hard]

* 后序遍历：左子树 ---> 右子树 ---> 根结点

* 前序的修正版
* 先按root->right->left的反顺得到结果(类似前序)
* 结果压入root,栈中先后压入left->right(相当于**root->right->left**的顺序)
* 结果逆序输出

### 102、二叉树的层次遍历[Medium]

==深度搜索,不是深度优先搜索==

* 层次遍历：从上到下，从左到右

* 定义递归函数fun(root,level,result)
* 如果递归的层level加深了,result加入空列表[]
* 递归调用函数,root变为它的子节点,深度加深

---

## 二叉树重构

### 105、从前序与中序遍历序列构造二叉树[Medium]

* 前序的头就是root,查询完需要pop掉,否则无法下一步
* 查询索引的函数index
* 中序中,root值左边就是左子树,右边是右子树
* 递归构造子树先left后right

### 106、从中序与后序遍历序列构造二叉树[Medium]

* 后序的尾部就是root,查询完需要pop掉,否则无法下一步
* 中序中,root值左边就是左子树,右边是右子树
* ==递归构造子树先right后left==









